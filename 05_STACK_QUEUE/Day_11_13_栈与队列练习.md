## 有效的括号

### 例题

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

### 三种不匹配情况

*   字符串里左方向的括号多余 ，所以不匹配

*   括号没有多余，括号的类型没有匹配上

*   字符串里右方向的括号多余，所以不匹配

```C++
class Solution
{
public:
   // 判断给定的字符串是否是有效的括号表达式
   bool isValid(string s)
   {
       // 如果字符串长度是奇数，直接返回false，因为括号表达式必须是偶数长度
       if (s.size() % 2 != 0)
       {
           return false;
       }

       // 创建一个栈，用于存储待匹配的括号
       stack<char> st;
       // 遍历字符串中的每个字符
       for (int i = 0; i < s.size(); i++)
       {
           // 如果当前字符是左括号，则将对应的右括号压入栈中
           if (s[i] == '(')
           {
               st.push(')');
           }
           // 如果当前字符是左方括号，则将对应的右方括号压入栈中
           else if (s[i] == '[')
           {
               st.push(']');
           }
           // 如果当前字符是左花括号，则将对应的右花括号压入栈中
           else if (s[i] == '{')
           {
               st.push('}');
           }
           // 如果栈为空或者栈顶元素不等于当前字符，则返回false，因为括号没有正确匹配
           else if (st.empty() || st.top() != s[i])
           {
               return false;
           }
           // 如果栈顶元素等于当前字符，则弹出栈顶元素，表示括号已经匹配
           else
           {
               st.pop();
           }
               
       }
       // 如果栈为空，则表示所有的括号都已经匹配，返回true；否则返回false
       return st.empty();
   }
};
```

*   时间复杂度: O(n)

*   空间复杂度: O(n)

## 删除字符串中的所有相邻重复项

### 例题

[1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

##### 普通解法

```C++
class Solution
{
public:
   // 定义一个函数，用于移除字符串中的重复字符
   string removeDuplicates(string s)
   {
       string result;  // 定义一个字符串用于存储结果
       stack<char> st;  // 定义一个栈用于存储字符
       for (int i = 0; i < s.size(); i++)  // 遍历输入字符串
       {
           if (st.empty() || s[i] != st.top())  // 如果栈为空或者当前字符与栈顶字符不同
           {
               st.push(s[i]);  // 将当前字符入栈
           }
           else if (s[i] == st.top())  // 如果当前字符与栈顶字符相同
           {
               st.pop();  // 将栈顶字符出栈
           }
       }
       while (!st.empty())  // 当栈不为空时
       {
           result += st.top();  // 将栈顶字符添加到结果字符串
           st.pop();  // 将栈顶字符出栈
       }
       reverse(result.begin(), result.end());  // 将结果字符串反转
       return result;  // 返回结果
   }
};
```

*   时间复杂度: O(n)

*   空间复杂度: O(n)

##### 字符串直接作为栈

```C++
class Solution
{
public:
   // 定义一个函数，用于移除字符串中的重复字符
   string removeDuplicates(string S)
   {
       string result;  // 定义一个字符串result用于存储结果
       for (char s : S)  // 遍历输入的字符串S
       {
           if (result.empty() || result.back() != s)  // 如果result为空或者result的最后一个字符不等于当前字符s
           {
               result.push_back(s);  // 将当前字符s添加到result的末尾
           }
           else  // 如果result的最后一个字符等于当前字符
           {
               result.pop_back();  // 将result的最后一个字符移除
           }
       }
       return result;  // 返回处理后的字符串
   }
};
```

*   时间复杂度: O(n)

*   空间复杂度: O(1)，返回值不计空间复杂度

### 递归与栈

*   **递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因

*   **在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

